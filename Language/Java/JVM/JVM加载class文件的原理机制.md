# JVM加载class文件的原理机制

## JVM是什么
JVM全称Java Virtual Machine,也就是在计算机上再虚拟一个计算机。

我们知道计算机的基本构成是：运算器、控制器、存储器、输入和输出设备。JVM也是有这成套的元素，运算器最终当然还是交给CPU处理了，只是为了适应“一次编程，随处运行”的情况，需要做一个翻译动作，于是就用了JVM自己的命令集。这与汇编的命令集有点类似，每一种汇编命令针对一个系列的CPU，比如8086系列的汇编也是可以用在8088上的，但是就不能跑在8051上。然而，JVM的命令集则是可以到处运行的额，因为JVM做了翻译，根据不同的CPU，翻译成了不同的机器语言。

JVM是运行在操作系统之上的，它与硬件没有直接的交互。

![](img/1.png)

## JVM的组成部分

![](img/2.png)

通过这个构成图我们发现整个JVM分为四部分：
  1. 类加载器（Class Loader）

  类加载器的作用就是加载类文件到内存。比如我们编写了一个HelloWorld.java程序，然后通过javac编译成class文件，那怎么才能加载到内存中被执行呢？Class Loader承担的就是这个责任。

  不过，不是随便一个.class文件就能被加载，类加载器加载的class文件是有格式要求的。具体格式参见《JVM Specification 》。

  另外，类加载器只管加载，只要符合文件结构就加载，至于能不能运行，则不是它负责，那是由执行引擎负责。

  2. 运行数据区（Runtime data area）

  运行数据区是整个JVM的重点。我们所有写的程序都被加载到这里，之后才开始运行。Java生态系统如此的繁荣，得益于该区域的优良自治。

  3. 执行引擎（Execution Engine）

  执行引擎也叫做解释器（Interpreter），负责解释命令，然后将命令提交操作系统执行。

  4. 本地接口（Native Interface）

  本地接口的作用是融合不同的变成语言为Java所用，它的初衷是融合C/C++程序。Java诞生的时候是C/C++横行的时候，要想立足，必须有一个聪明的、睿智的调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是Native Method Stack中等级native方法，在Execution Engine执行时加载native libraier。目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机，或者Java系统管理生产设备，在企业级应用中已经比较少见了。因为现在的异构领域间的通信很发达，比如可以使用Socket 通信，也可以使用Web Service 等等，不多做介绍。

## JVM加载class文件的原理机制
Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类加载器，因为这些都是隐式装载的；只有我们用特殊的用法，比如反射，才会显示的加载所需要的类。

Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类（像是基类）完全加载到jvm中；至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。

### 隐式加载与显式加载
  *
