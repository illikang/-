# HTTP协议与TCP协议简单理解

TCP协议对应于传输层，而HTTP协议对应于应用层，从本质上来说，二者没有可比性。HTTP协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次HTTP请求。HTTP会通过TCP建立起一个到服务器的链接通道，当本次请求需要的数据传输完毕后，HTTP会立即将TCP连接断开，这个过程是很短的。

所以HTTP连接是一种短连接，是一种无状态的连接。所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过同一个连接，而是每次都建立一个新的连接。如果是一个连接的话，服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。而每次请求结束后，连接就关闭，相关的内容就释放了。所以记不住任何状态，成为无状态链接。

随着时间的推移，html页面变得复杂了，里面可能嵌入了很多图片，这时候访问图片都需要建立一次TCP连接就显得低效了。因此Keep-Alive被提出用来解决效率低的问题。从HTTP/1.1起，默认都启用了Keep-Alive,保持连接特性。简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP链接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。虽然这里使用TCP连接保持了一段时间，但是这个时间是有限范围，到了时间点依然是会关闭的，所以我们还是它看作是每次连接完成后就会关闭。后来，通过Session,Cookie等相关技术，也能保持一些用户的状态。但是还是每次都是用一个新的连接，依然是无状态连接。

以前有个概念很容易搞不清楚，就是为什么HTTP是无状态的短链接，而TCP是有状态的长连接？HTTP不是建立在TCP的基础上吗，为什么还能是短连接？现在明白了，HTTP就是在每次请求完成后就把TCP连接关了，所以是短连接。而我们直接通过Socket编程使用TCP协议的时候，因为我们自己可以通过代码区控制什么时候打开链接，什么时候关闭连接，只要我们不通过代码把连接关闭，这个连接就会在客户端和服务端的进程中一次存在，相关状态数据会一直保存着。

HTTP/1.0和HTTP/1.1都把TCP作为底层的传输协议。HTTP客户首先发起建立与服务器TCP连接。一旦建立连接，浏览器进程和服务器进程就可以通过各自的Socket来方位TCP。如前所述，客户端Socket是客户进程和TCP连接之间的“门”，服务器端Socket是服务器进程和同一TCP连接之间的“门”。客户往自己的Socket发送HTTP请求消息，也从自己的Socket接收HTTP相应消息。客户或服务器一旦把这个消息送入各自的Socket,这个消息就完全落入TCP的控制之中。TCP给HTTP提供一个可靠的数据传输服务；这意味着由客户发出的每个HTTP请求消息最终无损地到达服务器，由服务器发出的每个HTTP响应消息也最终无损得到达客户。

FTP的底层也是TCP，不过是长连接。传输大文件比较快，需要看具体场景。在服务器端，如果程序是采取的长连接的方式，那么就能控制同时连接到这个服务器的连接个数，防止同时有多个连接。但是采取短连接的方式，那么就不能控制同时连接到这个服务器上的连接的个数，这也是一个优点，可以同时处理大量连接请求。但是如果连接请求量太大的话，可能造成服务器停止工作。

WebService不需要连接，1秒钟至少可以支持上万/十万的请求，每次请求然后释放，没有空余的内存消耗。一般不会限制同时连接的个数，这是优势。Message Queue需要建立连接，支持上千的链接就很吃力了。因为每个链接即使没有在请求数据，也会在内存中占用一定的空间存储，会限制。比如SQL Server数据库服务器，一般最多同时连接16个。

HTTP协议一般通过指定的端口80，所以一般计算机上不会限制这个端口，所以HTTP协议能够顺利通过所有机器上的防火墙。而使用Socket编程的话，就需要自己制定特定的端口，那么很可能这个端口是在某个环境中禁用的，那么就无法穿透防火墙。IIS使用的是端口80，也就是这个程序一直在监听着这个端口。一旦发现有人要建立这个端口的连接，他就会响应，然后建立连接。这里说的连接都是短连接。所以你对服务器上的网址的请求，都是通过80端口送到网站程序的。然后通过这个端口发送到客户端浏览器。

原文地址：https://www.cnblogs.com/dingjiaoyang/p/5326544.html
