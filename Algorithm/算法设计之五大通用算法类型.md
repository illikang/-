<!-- GFM-TOC -->
# 算法设计之五大通用类型算法
在一段时间的算法学习以后，我们会有一定量的算法积累。借助这些算法，我们可以解决许多现成的问题。并且我们可以看到，当一个算法给定时，具体的数据结构无需指定。为使运行时间尽可能得少，需要由编程人员来选择适当的数据结构。

但是，有时候我们不得不把注意力从算法的实现转向算法的设计，因为已有的算法和数据结构并不能完全解决我们在编程中遇到的所有问题。

因此，这里我们将集中介绍用于求解问题的五种通用类型的算法。对于许多问题，很可能这些方法中至少有一种方法是可以解决问题的。对于这五种算法，这里只是总体介绍，主要是带来整天认知和思想启示。至于每种算法的详细内容，我们将在每种算法的专题中展开。

## 贪婪算法（greedy algorithm）
贪婪算法分阶段地工作。在每一个阶段，可以认为所做决定是好的，而不考虑将来的后果。通常，这意味着选择的是某个局部最优。这种“眼下能够拿到的就拿”的策略是这类算法名称的来源。当算法终止时，我们希望局部最优等于全局最优。如果是这样的话，那么算法就是正确的；否则，算法得到的是一个次最优解（suboptimal solution）。如果不要求绝对最佳答案，那么有时可以选择使用简单的贪婪算法生成近似的答案，而不是使用通常产生准确答案所需要的复杂算法。

贪婪算法的例子：Dijkstra算法、Prim算法和Kruskal算法。

## 分治算法(divide and conquer)
分治算法由两部分组成：
  * 分（divide）：递归解决较小的问题（基本情况除外）
  * 治（conquer）：然后从子问题的解构建原问题的解

传统上，在正文中至少含有两个递归调用的例程才叫作分治算法，而正文中只含有一个递归调用的例程不是分治算法。一般我们认为子问题是不相交的。

分治算法的例子：归并排序，快速排序。

## 动态规划(dynamice programming)
当最优化问题具有重复子问题和最优子结构的时候，就是动态规划出场的时候了。动态规划算法的核心就是提供了一个memory来缓存重复子问题的结果，避免了递归的过程中的大量的重复计算。动态规划算法的难点在于怎么将问题转化为能够利用动态规划算法来解决。当重复子问题的数目比较小时，动态规划的效果也会很差。如果问题存在大量的重复子问题的话，那么动态规划对于效率的提高是非常恐怖的。就像斗转星移武功，对手强它也会比较强，对手若，他也会比较弱。

## 回溯算法(backtracking)
回溯算法是深度优先策略的典型应用，回溯算法就是沿着一条路向下走，如果此路不同了，则回溯到上一个
分岔路，在选一条路走，一直这样递归下去，直到遍历万所有的路径。八皇后问题是回溯算法的一个经典问题，还有一个经典的应用场景就是迷宫问题。

## 分支限界法
分支定界法的思想是：首先定义问题的解空间，并把问题的解空间转化成了图或者树的结构表示，然后使用广度优先搜索或者最小耗费（最大收益）策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。

基本思想类同于：图的广度优先搜索，二叉树的层序遍历。
