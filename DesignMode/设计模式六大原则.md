# 设计模式六大原则

## 设计原则
原则，指的是一种方向，一种方式，一种约束，而不是具体的方法。相应的，软件设计模式的六大原则，告诉我们的是设计的方向和约束，而不是具体设计的方法。

因正因为如此，设计原则比设计模式更抽象，更不容易掌握。它需要更多的使用和实践才能使自己脑海中的原则丰满起来。就好像人只有经历了更多的事情，才会对原则有更深刻的理解。

## 一、单一职责原则
不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如果不然，就应该把类拆分。

在软件系统中，一个类（大到模块、小到方法）承担的职责越多，它被复用的可能性就越小；而一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生则可将他们封装在同一类中。

单一职责原则是实现高内聚、低耦合的知道方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。

## 二、开闭原则
一个软件实体应当对拓展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

为了满足开闭原则，需要对系统进行抽象画设计，抽象化是开闭原则的关键。在Java、C#编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行拓展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上拓展系统的功能，达到开闭原则的要求。

## 三、里氏替换原则
有引用基类（父类）的地方必须能透明地使用其子类的对象。里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能根据此断定我喜欢动物，因为我可能并不喜欢猫。

里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型对对象进行定义，而再运行时再确定其子类类型，用子类对象来替换父类对象。

在使用里氏替换原则是需要注意如下几个问题：

  1. 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏替换原则，为了保证系统的拓展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
  2. 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。

## 四、依赖倒置原则
抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。

如果说开闭原则是面向对象设计的目标的化，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。它的实现主要有两方面：一、程序中尽量使用抽象层进行编程，而将具体类写在配置文件中。二、具体的类对象通过依赖注入的方式注入到其他对象中。下面具体说明：
  * 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明、以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给多余的方法，否则将无法调用到子类中增加的新方法。
  * 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无需修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。
  * 在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。

## 五、接口隔离原则

## 六、迪米特法则（最少知道原则）
一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法内部，通过public方法提供给外部。这样当被依赖的的类变化时，才能最小的影响该类。

知道原则的另一个表达式：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接朋友。我们要求陌生的类不要作为局部变量出现在类中。

## 如何理解这些原则
所有这些原则，综合起来为我们描绘了一个类与类之间互相关联，且同时能最大程度上解耦合的设计框架：
  1. 每个类的职责单一，只负责它应该负责的事情。如此，我们的“大厦”有了明确可复用的“部件”。落成的大厦最然无比复杂，但构成它的部件，不外乎，水泥，沙子，钢筋，管材等，每个部件只有单一的职责，但并不影响他们合成复杂的大厦。类职责单一使得整体设计条理更加清晰，同时也提高了类的可复用性。类的职责越多，它的可用性反而越低。
  2. 为了使我们的“大厦”设计具有更好的拓展性，我们在设计类时应该面向接口或抽象类，而不是具体实现。比如：我们的大厦统统使用钢筋，至于具体使用什么钢筋，则通过外部文件指定，如此，加入将来有了新型钢筋，我们只需要修改外部文件参数就可以，“大厦”的设计无需任何改变；反之，如果一开始就写死了钢筋的参数，那么一旦要选用新型钢筋，那整个设计的无数地方都需要修改。
  3. 前俩点告诉我们，首先去设计单一功能的抽象部件。这样才能具备可拓展、可复用的可能。
  5. 在处理类与类之间的关系时，应该尽量让每个类只跟它的直接朋友（主要是成员变量）通讯，而不要和间接朋友（局部变量、临时变量）通信。
  4. 抽象部件能完成我们框架设计，但最终实现还是用实现类。借助依赖注入的方式，将具体类的对象通过依赖注入的方式注入到其他对象中，我们可以完成不同类之间的互相集成，以松耦合的方式完成类与类之间的引用（直接朋友）。
